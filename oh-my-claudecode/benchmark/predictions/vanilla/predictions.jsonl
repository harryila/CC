{"instance_id": "astropy__astropy-12907", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e272..45bea360 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])"}
{"instance_id": "astropy__astropy-13033", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f..c83748dd 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -76,9 +76,15 @@ class BaseTimeSeries(QTable):\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                if len(self.colnames) < len(required_columns):\n+                    raise ValueError(\"{} object is invalid - expected '{}' \"\n+                                     \"as the first column{} but time series has only {} column{}\"\n+                                     .format(self.__class__.__name__, \"', '\".join(required_columns), plural,\n+                                             len(self.colnames), 's' if len(self.colnames) > 1 else ''))\n+                else:\n+                    raise ValueError(\"{} object is invalid - expected '{}' \"\n+                                     \"as the first column{} but found '{}'\"\n+                                     .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):"}
{"instance_id": "astropy__astropy-13236", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127..ce2708e5 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1243,6 +1243,14 @@ class Table:\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            warnings.warn(\n+                \"Adding a structured np.ndarray to a Table will result in a \"\n+                \"NdarrayMixin column instead of a Column. To avoid this warning \"\n+                \"and get a Column, convert the structured array to a Column with \"\n+                \"Column(data) before adding to the Table. \"\n+                \"In a future release the structured array will be converted to \"\n+                \"a Column by default.\",\n+                FutureWarning)\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n \ndiff --git a/astropy/table/tests/test_mixin.py b/astropy/table/tests/test_mixin.py\nindex 2fdcd20d..965493d6 100644\n--- a/astropy/table/tests/test_mixin.py\n+++ b/astropy/table/tests/test_mixin.py\n@@ -712,10 +712,14 @@ def test_ndarray_mixin():\n     d = np.arange(8, dtype='i8').reshape(4, 2).view(NdarrayMixin)\n \n     # Add one during initialization and the next as a new column.\n-    t = Table([a], names=['a'])\n-    t['b'] = b\n-    t['c'] = c\n-    t['d'] = d\n+    # Adding a, b, c as structured arrays triggers a FutureWarning.\n+    with pytest.warns(FutureWarning, match='Adding a structured np.ndarray'):\n+        t = Table([a], names=['a'])\n+    with pytest.warns(FutureWarning, match='Adding a structured np.ndarray'):\n+        t['b'] = b\n+    with pytest.warns(FutureWarning, match='Adding a structured np.ndarray'):\n+        t['c'] = c\n+    t['d'] = d  # d is already an NdarrayMixin, so no warning\n \n     assert isinstance(t['a'], NdarrayMixin)"}
{"instance_id": "django__django-11477", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/django/urls/base.py b/django/urls/base.py\nindex 0e1c3d90..a0f70db0 100644\n--- a/django/urls/base.py\n+++ b/django/urls/base.py\n@@ -172,7 +172,10 @@ def translate_url(url, lang_code):\n         to_be_reversed = \"%s:%s\" % (match.namespace, match.url_name) if match.namespace else match.url_name\n         with override(lang_code):\n             try:\n-                url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs)\n+                # Filter out None values from kwargs - these come from optional\n+                # named groups that didn't match in the URL pattern.\n+                kwargs = {k: v for k, v in match.kwargs.items() if v is not None}\n+                url = reverse(to_be_reversed, args=match.args, kwargs=kwargs)\n             except NoReverseMatch:\n                 pass\n             else:"}
{"instance_id": "django__django-11490", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 08d7faf1..8172b3c5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -333,6 +333,7 @@ class Query(BaseExpression):\n             del obj.base_table\n         except AttributeError:\n             pass\n+        obj.combined_queries = tuple([q.clone() for q in self.combined_queries])\n         return obj\n \n     def chain(self, klass=None):"}
{"instance_id": "django__django-11532", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/django/core/mail/utils.py b/django/core/mail/utils.py\nindex d18dfe46..b7bdc01d 100644\n--- a/django/core/mail/utils.py\n+++ b/django/core/mail/utils.py\n@@ -14,6 +14,13 @@ class CachedDnsName:\n     def get_fqdn(self):\n         if not hasattr(self, '_fqdn'):\n             self._fqdn = socket.getfqdn()\n+            # Handle non-ASCII domain names by encoding them to punycode (IDNA).\n+            # This is necessary for email headers that may use encodings that\n+            # can't represent all Unicode characters.\n+            try:\n+                self._fqdn.encode('ascii')\n+            except UnicodeEncodeError:\n+                self._fqdn = self._fqdn.encode('idna').decode('ascii')\n         return self._fqdn"}
{"instance_id": "django__django-11551", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex f82c20c2..9fd77b5d 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        else:\n             try:\n                 field = obj.model._meta.get_field(item)\n             except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n+                try:\n+                    field = getattr(obj.model, item)\n+                except AttributeError:\n                     return [\n                         checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                            \"The value of '%s' refers to '%s', which is not a callable, \"\n+                            \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n+                                label, item, obj.__class__.__name__,\n+                                obj.model._meta.app_label, obj.model._meta.object_name,\n+                            ),\n                             obj=obj.__class__,\n-                            id='admin.E109',\n+                            id='admin.E108',\n                         )\n                     ]\n-                return []\n-        else:\n-            return [\n-                checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n-                    obj=obj.__class__,\n-                    id='admin.E108',\n-                )\n-            ]\n+            if isinstance(field, models.ManyToManyField):\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                        obj=obj.__class__,\n+                        id='admin.E109',\n+                    )\n+                ]\n+            return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display."}
{"instance_id": "django__django-11555", "model_name_or_path": "claude-code-vanilla", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex eaccc96d..09903e95 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,8 +722,16 @@ class SQLCompiler:\n \n             results = []\n             for item in opts.ordering:\n-                results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                if hasattr(item, 'resolve_expression'):\n+                    if not isinstance(item, OrderBy):\n+                        item = item.asc()\n+                    if descending:\n+                        item = item.copy()\n+                        item.reverse_ordering()\n+                    results.append((item, False))\n+                else:\n+                    results.extend(self.find_ordering_name(item, opts, alias,\n+                                                           order, already_seen))\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]"}
